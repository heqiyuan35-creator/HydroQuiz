/**
 * å¡ç‰‡æ•°æ®åŒæ­¥æœåŠ¡
 * å°† App æ•°æ®åŒæ­¥åˆ° Preferencesï¼Œä¾›å¡ç‰‡è¯»å–
 */
import { preferences } from '@kit.ArkData';
import { common } from '@kit.AbilityKit';
import { formBindingData, formProvider } from '@kit.FormKit';
import { BusinessError } from '@kit.BasicServicesKit';
import { Logger } from '../common/utils/Logger';

const PREFERENCES_NAME: string = 'hydro_quiz_prefs';

/**
 * å¡ç‰‡æ›´æ–°æ•°æ®ç±»
 */
class WidgetUpdateData {
  todayCount: number = 0;
  targetCount: number = 20; // ä¸Appé»˜è®¤å€¼ä¸€è‡´
  correctCount: number = 0;
  wrongCount: number = 0;
  accuracy: number = 0;
  isCheckedIn: boolean = false;
  streakDays: number = 0;
  progressPercent: number = 0;
  encourageText: string = '';
}

/**
 * å¡ç‰‡æ•°æ®æ¥å£
 */
export interface WidgetData {
  todayCount: number;
  targetCount: number;
  correctCount: number;
  wrongCount: number;
  isCheckedIn: boolean;
  streakDays: number;
  totalQuestions: number;
}

class WidgetDataService {
  private context: common.UIAbilityContext | null = null;

  /**
   * åˆå§‹åŒ–æœåŠ¡
   */
  init(context: common.UIAbilityContext): void {
    this.context = context;
  }

  /**
   * åŒæ­¥æ•°æ®åˆ° Preferences å¹¶æ›´æ–°å¡ç‰‡
   */
  async syncData(data: WidgetData): Promise<void> {
    if (!this.context) {
      Logger.error('[WidgetDataService] Context not initialized');
      return;
    }

    try {
      const pref = preferences.getPreferencesSync(this.context, { name: PREFERENCES_NAME });
      const today = new Date().toDateString();

      // ä¿å­˜æ•°æ®
      pref.putSync('lastStudyDate', today);
      pref.putSync('todayAnswerCount', data.todayCount);
      pref.putSync('dailyTarget', data.targetCount);
      pref.putSync('todayCorrectCount', data.correctCount);
      pref.putSync('todayWrongCount', data.wrongCount);
      pref.putSync('isCheckedInToday', data.isCheckedIn);
      pref.putSync('streakDays', data.streakDays);
      pref.putSync('totalQuestions', data.totalQuestions);

      await pref.flush();

      Logger.info('[WidgetDataService] Data synced to preferences');

      // æ›´æ–°æ‰€æœ‰å¡ç‰‡
      await this.updateAllWidgets(data);
    } catch (error) {
      Logger.error('[WidgetDataService] Failed to sync data', error as Error);
    }
  }

  /**
   * æ›´æ–°ä»Šæ—¥ç­”é¢˜æ•°æ®
   */
  async updateTodayStats(correctCount: number, wrongCount: number): Promise<void> {
    if (!this.context) return;

    try {
      const pref = preferences.getPreferencesSync(this.context, { name: PREFERENCES_NAME });
      const today = new Date().toDateString();
      const lastDate = pref.getSync('lastStudyDate', '') as string;

      // å¦‚æœæ˜¯æ–°çš„ä¸€å¤©ï¼Œé‡ç½®ç»Ÿè®¡
      if (lastDate !== today) {
        pref.putSync('lastStudyDate', today);
        pref.putSync('todayAnswerCount', 0);
        pref.putSync('todayCorrectCount', 0);
        pref.putSync('todayWrongCount', 0);
        pref.putSync('isCheckedInToday', false);
      }

      // æ›´æ–°ç»Ÿè®¡
      const currentTotal = pref.getSync('todayAnswerCount', 0) as number;
      const currentCorrect = pref.getSync('todayCorrectCount', 0) as number;
      const currentWrong = pref.getSync('todayWrongCount', 0) as number;

      pref.putSync('todayAnswerCount', currentTotal + correctCount + wrongCount);
      pref.putSync('todayCorrectCount', currentCorrect + correctCount);
      pref.putSync('todayWrongCount', currentWrong + wrongCount);

      await pref.flush();

      // è·å–å®Œæ•´æ•°æ®å¹¶æ›´æ–°å¡ç‰‡
      const data = await this.getWidgetData();
      await this.updateAllWidgets(data);

      Logger.info('[WidgetDataService] Today stats updated');
    } catch (error) {
      Logger.error('[WidgetDataService] Failed to update today stats', error as Error);
    }
  }

  /**
   * æ›´æ–°æ‰“å¡çŠ¶æ€
   */
  async updateCheckInStatus(isCheckedIn: boolean, streakDays: number): Promise<void> {
    if (!this.context) return;

    try {
      const pref = preferences.getPreferencesSync(this.context, { name: PREFERENCES_NAME });

      pref.putSync('isCheckedInToday', isCheckedIn);
      pref.putSync('streakDays', streakDays);

      await pref.flush();

      // è·å–å®Œæ•´æ•°æ®å¹¶æ›´æ–°å¡ç‰‡
      const data = await this.getWidgetData();
      await this.updateAllWidgets(data);

      Logger.info('[WidgetDataService] Check-in status updated');
    } catch (error) {
      Logger.error('[WidgetDataService] Failed to update check-in status', error as Error);
    }
  }

  /**
   * æ›´æ–°æ¯æ—¥ç›®æ ‡
   */
  async updateDailyTarget(target: number): Promise<void> {
    if (!this.context) {
      Logger.error('[WidgetDataService] Context not initialized when updating daily target');
      return;
    }

    try {
      const pref = preferences.getPreferencesSync(this.context, { name: PREFERENCES_NAME });
      pref.putSync('dailyTarget', target);
      await pref.flush();

      Logger.info(`[WidgetDataService] Daily target saved to preferences: ${target}`);

      // è·å–å®Œæ•´æ•°æ®å¹¶æ›´æ–°å¡ç‰‡
      const data = await this.getWidgetData();
      Logger.info(`[WidgetDataService] Widget data for update: todayCount=${data.todayCount}, targetCount=${data.targetCount}`);
      await this.updateAllWidgets(data);

      Logger.info(`[WidgetDataService] Daily target updated to ${target}`);
    } catch (error) {
      Logger.error('[WidgetDataService] Failed to update daily target', error as Error);
    }
  }

  /**
   * åˆå§‹åŒ–åŒæ­¥ - App å¯åŠ¨æ—¶è°ƒç”¨ï¼Œä»æ•°æ®åº“åŒæ­¥å½“å‰æ•°æ®åˆ°å¡ç‰‡ Preferences
   */
  async initSync(todayCount: number, correctCount: number, wrongCount: number, dailyTarget: number, isCheckedIn: boolean): Promise<void> {
    if (!this.context) return;

    try {
      const pref = preferences.getPreferencesSync(this.context, { name: PREFERENCES_NAME });
      const today = new Date().toDateString();

      pref.putSync('lastStudyDate', today);
      pref.putSync('todayAnswerCount', todayCount);
      pref.putSync('todayCorrectCount', correctCount);
      pref.putSync('todayWrongCount', wrongCount);
      pref.putSync('dailyTarget', dailyTarget);
      pref.putSync('isCheckedInToday', isCheckedIn);

      await pref.flush();

      // æ›´æ–°å¡ç‰‡
      const data: WidgetData = {
        todayCount: todayCount,
        targetCount: dailyTarget,
        correctCount: correctCount,
        wrongCount: wrongCount,
        isCheckedIn: isCheckedIn,
        streakDays: 0,
        totalQuestions: 0
      };
      await this.updateAllWidgets(data);

      Logger.info(`[WidgetDataService] Init sync completed - today: ${todayCount}/${dailyTarget}, checked: ${isCheckedIn}`);
    } catch (error) {
      Logger.error('[WidgetDataService] Failed to init sync', error as Error);
    }
  }

  /**
   * è·å–å¡ç‰‡æ•°æ®
   */
  async getWidgetData(): Promise<WidgetData> {
    if (!this.context) {
      Logger.error('[WidgetDataService] Context not initialized when getting widget data');
      return this.getDefaultData();
    }

    try {
      const pref = preferences.getPreferencesSync(this.context, { name: PREFERENCES_NAME });
      const today = new Date().toDateString();
      const lastDate = pref.getSync('lastStudyDate', '') as string;
      const dailyTarget = pref.getSync('dailyTarget', 20) as number; // é»˜è®¤20ä¸Appä¸€è‡´

      // å¦‚æœä¸æ˜¯ä»Šå¤©çš„æ•°æ®ï¼Œè¿”å›é»˜è®¤å€¼ï¼ˆä½†ä¿ç•™dailyTargetï¼‰
      if (lastDate !== today) {
        return {
          todayCount: 0,
          targetCount: dailyTarget,
          correctCount: 0,
          wrongCount: 0,
          isCheckedIn: false,
          streakDays: pref.getSync('streakDays', 0) as number,
          totalQuestions: pref.getSync('totalQuestions', 0) as number
        };
      }

      return {
        todayCount: pref.getSync('todayAnswerCount', 0) as number,
        targetCount: dailyTarget,
        correctCount: pref.getSync('todayCorrectCount', 0) as number,
        wrongCount: pref.getSync('todayWrongCount', 0) as number,
        isCheckedIn: pref.getSync('isCheckedInToday', false) as boolean,
        streakDays: pref.getSync('streakDays', 0) as number,
        totalQuestions: pref.getSync('totalQuestions', 0) as number
      };
    } catch (error) {
      Logger.error('[WidgetDataService] Failed to get widget data', error as Error);
      return this.getDefaultData();
    }
  }

  /**
   * è·å–é»˜è®¤æ•°æ®
   */
  private getDefaultData(): WidgetData {
    return {
      todayCount: 0,
      targetCount: 20, // ä¸Appé»˜è®¤å€¼ä¸€è‡´
      correctCount: 0,
      wrongCount: 0,
      isCheckedIn: false,
      streakDays: 0,
      totalQuestions: 0
    };
  }

  /**
   * æ›´æ–°æ‰€æœ‰å¡ç‰‡
   */
  private async updateAllWidgets(data: WidgetData): Promise<void> {
    if (!this.context) return;

    try {
      const pref = preferences.getPreferencesSync(this.context, { name: PREFERENCES_NAME });
      const formIdsStr = pref.getSync('formIds', '') as string;

      if (!formIdsStr) {
        Logger.info('[WidgetDataService] No form ids found');
        return;
      }

      const formIds = formIdsStr.split(',').filter((id: string) => id.length > 0);
      const accuracy = data.todayCount > 0
        ? Math.round((data.correctCount / data.todayCount) * 100)
        : 0;
      const progressPercent = data.targetCount > 0
        ? Math.min(100, Math.round((data.todayCount / data.targetCount) * 100))
        : 0;

      // æ„å»ºæ›´æ–°æ•°æ®
      const updateData = new WidgetUpdateData();
      updateData.todayCount = data.todayCount;
      updateData.targetCount = data.targetCount;
      updateData.correctCount = data.correctCount;
      updateData.wrongCount = data.wrongCount;
      updateData.accuracy = accuracy;
      updateData.isCheckedIn = data.isCheckedIn;
      updateData.streakDays = data.streakDays;
      updateData.progressPercent = progressPercent;
      updateData.encourageText = this.getEncourageText(data.todayCount, data.targetCount, data.isCheckedIn);

      const formData = formBindingData.createFormBindingData(updateData);

      // æ›´æ–°æ‰€æœ‰å¡ç‰‡
      for (const formId of formIds) {
        formProvider.updateForm(formId, formData)
          .then(() => {
            Logger.info(`[WidgetDataService] Updated form: ${formId}`);
          })
          .catch((err: BusinessError) => {
            Logger.error(`[WidgetDataService] Failed to update form ${formId}: ${err.message}`);
          });
      }
    } catch (error) {
      Logger.error('[WidgetDataService] Failed to update widgets', error as Error);
    }
  }

  /**
   * è·å–é¼“åŠ±æ–‡æ¡ˆ
   */
  private getEncourageText(todayCount: number, targetCount: number, isCheckedIn: boolean): string {
    if (todayCount === 0) {
      return 'ğŸ“š å¼€å§‹ä»Šå¤©çš„å­¦ä¹ å§ï¼';
    }
    if (isCheckedIn) {
      return 'ğŸ‰ ä»Šæ—¥å·²æ‰“å¡ï¼Œç»§ç»­ä¿æŒï¼';
    }
    if (todayCount >= targetCount) {
      return 'ğŸ”¥ ç›®æ ‡è¾¾æˆï¼Œç»§ç»­çŒ›å†²ï¼';
    }
    const remaining = targetCount - todayCount;
    return `ğŸ’ª è¿˜å·® ${remaining} é¢˜å®Œæˆç›®æ ‡`;
  }
}

export const widgetDataService = new WidgetDataService();
