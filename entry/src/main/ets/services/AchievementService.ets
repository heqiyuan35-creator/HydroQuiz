/**
 * æˆå°±ç³»ç»ŸæœåŠ¡
 * HydroQuiz - æ°´åˆ©å·¥ç¨‹æ£€æµ‹å‘˜åˆ·é¢˜å®
 */
import { preferences } from '@kit.ArkData';
import { databaseService } from '../data/database/DatabaseService';
import { answerRecordService } from './AnswerRecordService';
import { mockExamService } from './MockExamService';
import { Logger } from '../common/utils/Logger';
import { achievementNotificationService } from './AchievementNotificationService';

// æˆå°±å®šä¹‰
export interface Achievement {
  id: string;
  name: string;
  description: string;
  icon: string;
  category: string;
  condition: string;
  targetValue: number;
  isUnlocked: boolean;
  unlockTime: number;
  progress: number;
}

// æˆå°±ç±»åˆ«
export const ACHIEVEMENT_CATEGORIES: string[] = ['å­¦ä¹ ', 'è€ƒè¯•', 'åšæŒ', 'æŒ‘æˆ˜'];

// æˆå°±å®šä¹‰åˆ—è¡¨
const ACHIEVEMENT_DEFINITIONS: Achievement[] = [
  // å­¦ä¹ ç±»
  { id: 'first_question', name: 'åˆå‡ºèŒ…åº', description: 'å®Œæˆç¬¬ä¸€é“é¢˜ç›®', icon: 'ğŸŒ±', category: 'å­¦ä¹ ', condition: 'questions', targetValue: 1, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'questions_10', name: 'å°è¯•ç‰›åˆ€', description: 'ç´¯è®¡å®Œæˆ10é“é¢˜ç›®', icon: 'ğŸ“', category: 'å­¦ä¹ ', condition: 'questions', targetValue: 10, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'questions_50', name: 'å‹¤å­¦è‹¦ç»ƒ', description: 'ç´¯è®¡å®Œæˆ50é“é¢˜ç›®', icon: 'ğŸ“š', category: 'å­¦ä¹ ', condition: 'questions', targetValue: 50, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'questions_100', name: 'ç™¾é¢˜æ–©', description: 'ç´¯è®¡å®Œæˆ100é“é¢˜ç›®', icon: 'ğŸ’¯', category: 'å­¦ä¹ ', condition: 'questions', targetValue: 100, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'questions_500', name: 'é¢˜æµ·æˆ˜æœ¯', description: 'ç´¯è®¡å®Œæˆ500é“é¢˜ç›®', icon: 'ğŸ†', category: 'å­¦ä¹ ', condition: 'questions', targetValue: 500, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'questions_1000', name: 'åƒé¢˜å¤§å¸ˆ', description: 'ç´¯è®¡å®Œæˆ1000é“é¢˜ç›®', icon: 'ğŸ‘‘', category: 'å­¦ä¹ ', condition: 'questions', targetValue: 1000, isUnlocked: false, unlockTime: 0, progress: 0 },
  
  // è€ƒè¯•ç±»
  { id: 'first_exam', name: 'åˆæ¬¡æ¨¡è€ƒ', description: 'å®Œæˆç¬¬ä¸€æ¬¡æ¨¡æ‹Ÿè€ƒè¯•', icon: 'ğŸ“‹', category: 'è€ƒè¯•', condition: 'exams', targetValue: 1, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'exam_pass', name: 'é¦–æˆ˜å‘Šæ·', description: 'æ¨¡æ‹Ÿè€ƒè¯•é¦–æ¬¡åŠæ ¼', icon: 'âœ…', category: 'è€ƒè¯•', condition: 'exam_pass', targetValue: 1, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'exam_90', name: 'ä¼˜ç§€å­¦å‘˜', description: 'æ¨¡æ‹Ÿè€ƒè¯•å¾—åˆ†90åˆ†ä»¥ä¸Š', icon: 'ğŸŒŸ', category: 'è€ƒè¯•', condition: 'exam_score', targetValue: 90, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'exam_100', name: 'æ»¡åˆ†è¾¾äºº', description: 'æ¨¡æ‹Ÿè€ƒè¯•è·å¾—æ»¡åˆ†', icon: 'ğŸ’', category: 'è€ƒè¯•', condition: 'exam_score', targetValue: 100, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'exams_5', name: 'è€ƒè¯•è¾¾äºº', description: 'ç´¯è®¡å®Œæˆ5æ¬¡æ¨¡æ‹Ÿè€ƒè¯•', icon: 'ğŸ¯', category: 'è€ƒè¯•', condition: 'exams', targetValue: 5, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'exams_10', name: 'èº«ç»ç™¾æˆ˜', description: 'ç´¯è®¡å®Œæˆ10æ¬¡æ¨¡æ‹Ÿè€ƒè¯•', icon: 'âš”ï¸', category: 'è€ƒè¯•', condition: 'exams', targetValue: 10, isUnlocked: false, unlockTime: 0, progress: 0 },
  
  // åšæŒç±»
  { id: 'streak_3', name: 'ä¸‰å¤©æ‰“é±¼', description: 'è¿ç»­å­¦ä¹ 3å¤©', icon: 'ğŸ”¥', category: 'åšæŒ', condition: 'streak', targetValue: 3, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'streak_7', name: 'ä¸€å‘¨åšæŒ', description: 'è¿ç»­å­¦ä¹ 7å¤©', icon: 'ğŸ’ª', category: 'åšæŒ', condition: 'streak', targetValue: 7, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'streak_30', name: 'æœˆåº¦ä¹‹æ˜Ÿ', description: 'è¿ç»­å­¦ä¹ 30å¤©', icon: 'ğŸŒ™', category: 'åšæŒ', condition: 'streak', targetValue: 30, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'study_days_7', name: 'å­¦ä¹ æ–°æ‰‹', description: 'ç´¯è®¡å­¦ä¹ 7å¤©', icon: 'ğŸ“…', category: 'åšæŒ', condition: 'study_days', targetValue: 7, isUnlocked: false, unlockTime: 0, progress: 0 },
  
  // æŒ‘æˆ˜ç±»
  { id: 'accuracy_80', name: 'å‡†ç¡®å°„æ‰‹', description: 'æ€»æ­£ç¡®ç‡è¾¾åˆ°80%', icon: 'ğŸ¯', category: 'æŒ‘æˆ˜', condition: 'accuracy', targetValue: 80, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'accuracy_90', name: 'ç¥æªæ‰‹', description: 'æ€»æ­£ç¡®ç‡è¾¾åˆ°90%', icon: 'ğŸ¹', category: 'æŒ‘æˆ˜', condition: 'accuracy', targetValue: 90, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'wrong_master_10', name: 'é”™é¢˜å…‹æ˜Ÿ', description: 'æŒæ¡10é“é”™é¢˜', icon: 'âœ¨', category: 'æŒ‘æˆ˜', condition: 'mastered', targetValue: 10, isUnlocked: false, unlockTime: 0, progress: 0 },
  { id: 'wrong_master_50', name: 'é”™é¢˜ç»ˆç»“è€…', description: 'æŒæ¡50é“é”™é¢˜', icon: 'ğŸ”®', category: 'æŒ‘æˆ˜', condition: 'mastered', targetValue: 50, isUnlocked: false, unlockTime: 0, progress: 0 }
];

class AchievementService {
  private store: preferences.Preferences | null = null;
  private readonly STORE_NAME = 'achievements';

  async init(context: Context): Promise<void> {
    try {
      this.store = await preferences.getPreferences(context, this.STORE_NAME);
    } catch (error) {
      Logger.error('[AchievementService] Init failed', error as Error);
    }
  }

  // è·å–æ‰€æœ‰æˆå°±åŠå…¶çŠ¶æ€
  async getAllAchievements(): Promise<Achievement[]> {
    const achievements: Achievement[] = [];
    
    for (const def of ACHIEVEMENT_DEFINITIONS) {
      const achievement: Achievement = {
        id: def.id,
        name: def.name,
        description: def.description,
        icon: def.icon,
        category: def.category,
        condition: def.condition,
        targetValue: def.targetValue,
        isUnlocked: await this.isUnlocked(def.id),
        unlockTime: await this.getUnlockTime(def.id),
        progress: await this.getProgress(def)
      };
      achievements.push(achievement);
    }
    
    return achievements;
  }

  // æ£€æŸ¥å¹¶è§£é”æˆå°±ï¼Œè¿”å›æ–°è§£é”çš„æˆå°±
  async checkAndUnlock(): Promise<Achievement[]> {
    const newlyUnlocked: Achievement[] = [];
    
    for (const def of ACHIEVEMENT_DEFINITIONS) {
      if (await this.isUnlocked(def.id)) continue;
      
      const progress = await this.getProgress(def);
      if (progress >= def.targetValue) {
        await this.unlock(def.id);
        const achievement: Achievement = {
          id: def.id,
          name: def.name,
          description: def.description,
          icon: def.icon,
          category: def.category,
          condition: def.condition,
          targetValue: def.targetValue,
          isUnlocked: true,
          unlockTime: Date.now(),
          progress: progress
        };
        newlyUnlocked.push(achievement);
      }
    }
    
    return newlyUnlocked;
  }

  /**
   * æ£€æŸ¥æˆå°±å¹¶è‡ªåŠ¨é€šçŸ¥ï¼ˆç”¨äºå®æ—¶è§¦å‘ï¼‰
   * åœ¨ç­”é¢˜ã€è€ƒè¯•å®Œæˆç­‰å…³é”®æ—¶åˆ»è°ƒç”¨
   */
  async checkAndNotify(): Promise<void> {
    try {
      const newlyUnlocked = await this.checkAndUnlock();
      for (const achievement of newlyUnlocked) {
        achievementNotificationService.notify(achievement);
        Logger.info(`[AchievementService] Achievement unlocked: ${achievement.name}`);
      }
    } catch (error) {
      Logger.error('[AchievementService] Failed to check and notify', error as Error);
    }
  }

  private async getProgress(def: Achievement): Promise<number> {
    try {
      switch (def.condition) {
        case 'questions':
          return await this.getCompletedQuestionCount();
        case 'exams':
          return await this.getExamCount();
        case 'exam_pass':
          return await this.getPassedExamCount();
        case 'exam_score':
          return await this.getHighestExamScore();
        case 'streak':
          return await this.getCurrentStreak();
        case 'study_days':
          return await this.getStudyDays();
        case 'accuracy':
          return await this.getOverallAccuracy();
        case 'mastered':
          return await this.getMasteredCount();
        default:
          return 0;
      }
    } catch (error) {
      return 0;
    }
  }

  private async getCompletedQuestionCount(): Promise<number> {
    try {
      const store = databaseService.getStore();
      const resultSet = await store.querySql(
        'SELECT COUNT(DISTINCT question_id) as count FROM answer_records'
      );
      if (resultSet.goToFirstRow()) {
        const count = resultSet.getLong(resultSet.getColumnIndex('count'));
        resultSet.close();
        return count;
      }
      resultSet.close();
      return 0;
    } catch (error) {
      return 0;
    }
  }

  private async getExamCount(): Promise<number> {
    try {
      const records = await mockExamService.getExamHistory(100);
      return records.length;
    } catch (error) {
      return 0;
    }
  }

  private async getPassedExamCount(): Promise<number> {
    try {
      const records = await mockExamService.getExamHistory(100);
      return records.filter(r => r.isPassed).length;
    } catch (error) {
      return 0;
    }
  }

  private async getHighestExamScore(): Promise<number> {
    try {
      const records = await mockExamService.getExamHistory(100);
      if (records.length === 0) return 0;
      return Math.max(...records.map(r => r.score));
    } catch (error) {
      return 0;
    }
  }

  private async getCurrentStreak(): Promise<number> {
    try {
      const stats = await answerRecordService.getTodayStatistics();
      return stats.streak || 0;
    } catch (error) {
      return 0;
    }
  }

  private async getStudyDays(): Promise<number> {
    try {
      const store = databaseService.getStore();
      const resultSet = await store.querySql(
        "SELECT COUNT(DISTINCT date(create_time/1000, 'unixepoch', 'localtime')) as days FROM answer_records"
      );
      if (resultSet.goToFirstRow()) {
        const days = resultSet.getLong(resultSet.getColumnIndex('days'));
        resultSet.close();
        return days;
      }
      resultSet.close();
      return 0;
    } catch (error) {
      return 0;
    }
  }

  private async getOverallAccuracy(): Promise<number> {
    try {
      const stats = await answerRecordService.getTodayStatistics();
      return Math.round(stats.accuracy);
    } catch (error) {
      return 0;
    }
  }

  private async getMasteredCount(): Promise<number> {
    try {
      const store = databaseService.getStore();
      const resultSet = await store.querySql(
        'SELECT COUNT(*) as count FROM wrong_questions WHERE is_mastered = 1'
      );
      if (resultSet.goToFirstRow()) {
        const count = resultSet.getLong(resultSet.getColumnIndex('count'));
        resultSet.close();
        return count;
      }
      resultSet.close();
      return 0;
    } catch (error) {
      return 0;
    }
  }

  private async isUnlocked(achievementId: string): Promise<boolean> {
    if (!this.store) return false;
    try {
      return await this.store.get(`unlocked_${achievementId}`, false) as boolean;
    } catch (error) {
      return false;
    }
  }

  private async getUnlockTime(achievementId: string): Promise<number> {
    if (!this.store) return 0;
    try {
      return await this.store.get(`unlock_time_${achievementId}`, 0) as number;
    } catch (error) {
      return 0;
    }
  }

  private async unlock(achievementId: string): Promise<void> {
    if (!this.store) return;
    try {
      await this.store.put(`unlocked_${achievementId}`, true);
      await this.store.put(`unlock_time_${achievementId}`, Date.now());
      await this.store.flush();
    } catch (error) {
      Logger.error('[AchievementService] Unlock failed', error as Error);
    }
  }

  // è·å–ç»Ÿè®¡æ•°æ®
  async getStats(): Promise<AchievementStats> {
    const total = ACHIEVEMENT_DEFINITIONS.length;
    let unlocked = 0;
    const categories = new Map<string, number>();

    for (const cat of ACHIEVEMENT_CATEGORIES) {
      categories.set(cat, 0);
    }

    for (const def of ACHIEVEMENT_DEFINITIONS) {
      if (await this.isUnlocked(def.id)) {
        unlocked++;
        const current = categories.get(def.category) || 0;
        categories.set(def.category, current + 1);
      }
    }

    const stats = new AchievementStats();
    stats.total = total;
    stats.unlocked = unlocked;
    stats.categories = categories;
    return stats;
  }
}

/**
 * æˆå°±ç»Ÿè®¡ç»“æœç±»
 */
export class AchievementStats {
  total: number = 0;
  unlocked: number = 0;
  categories: Map<string, number> = new Map();
}

export const achievementService = new AchievementService();
