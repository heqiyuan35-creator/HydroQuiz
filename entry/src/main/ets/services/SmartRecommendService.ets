/**
 * æ™ºèƒ½æ¨èæœåŠ¡
 * HydroQuiz - æ°´åˆ©å·¥ç¨‹æ£€æµ‹å‘˜åˆ·é¢˜å®
 * åŸºäºç”¨æˆ·å­¦ä¹ æ•°æ®æä¾›ä¸ªæ€§åŒ–æ¨è
 */
import { answerRecordService } from './AnswerRecordService';
import { questionBankService, SubjectStats } from './QuestionBankService';
import { WrongQuestion } from '../common/types/QuestionTypes';
import { Logger } from '../common/utils/Logger';

/**
 * æ¨èç±»å‹
 */
export enum RecommendType {
  WEAK_POINT = 'weak_point',
  WRONG_REVIEW = 'wrong_review',
  NEW_LEARN = 'new_learn',
  DAILY_TASK = 'daily_task'
}

/**
 * æ¨èå¡ç‰‡æ•°æ®
 */
export interface RecommendCard {
  type: RecommendType;
  title: string;
  subtitle: string;
  icon: string;
  count: number;
  color: string;
  subjectId?: string;
  questionIds?: string[];
}

/**
 * ç§‘ç›®å­¦ä¹ è¿›åº¦
 */
export interface SubjectProgress {
  subjectId: string;
  subjectName: string;
  shortName: string;
  color: string;
  totalCount: number;
  completedCount: number;
  correctCount: number;
  wrongCount: number;
  progress: number;
  accuracy: number;
  masteryLevel: string;
  masteryColor: string;
}

/**
 * æŒæ¡ç¨‹åº¦ç»“æœ
 */
interface MasteryResult {
  level: string;
  color: string;
}

/**
 * å­¦ä¹ å»ºè®®
 */
export interface StudySuggestion {
  icon: string;
  title: string;
  description: string;
  action: string;
  priority: number;
}

/**
 * æ™ºèƒ½æ¨èæœåŠ¡ç±»
 */
class SmartRecommendService {
  private static instance: SmartRecommendService;

  private constructor() {}

  public static getInstance(): SmartRecommendService {
    if (!SmartRecommendService.instance) {
      SmartRecommendService.instance = new SmartRecommendService();
    }
    return SmartRecommendService.instance;
  }

  /**
   * è·å–ä»Šæ—¥æ¨èå¡ç‰‡
   */
  async getTodayRecommendCards(): Promise<RecommendCard[]> {
    const cards: RecommendCard[] = [];

    try {
      // 1. è·å–é”™é¢˜æ•°é‡
      const wrongCount = await answerRecordService.getWrongQuestionCount();
      if (wrongCount > 0) {
        const wrongCard: RecommendCard = {
          type: RecommendType.WRONG_REVIEW,
          title: 'é”™é¢˜å›é¡¾',
          subtitle: 'å·©å›ºè–„å¼±çŸ¥è¯†ç‚¹',
          icon: 'ğŸ“•',
          count: Math.min(wrongCount, 20),
          color: '#FF6B6B'
        };
        cards.push(wrongCard);
      }

      // 2. åˆ†æè–„å¼±ç§‘ç›®
      const weakSubject = await this.getWeakestSubject();
      if (weakSubject) {
        const weakCard: RecommendCard = {
          type: RecommendType.WEAK_POINT,
          title: 'è–„å¼±æ”»å…‹',
          subtitle: weakSubject.subjectName,
          icon: 'ğŸ¯',
          count: 15,
          color: '#FFB347',
          subjectId: weakSubject.subjectId
        };
        cards.push(weakCard);
      }

      // 3. æ–°é¢˜å­¦ä¹ æ¨è
      const todayStats = await answerRecordService.getTodayStatistics();
      const remainingGoal = Math.max(0, 50 - todayStats.total);
      if (remainingGoal > 0) {
        const newCard: RecommendCard = {
          type: RecommendType.NEW_LEARN,
          title: 'ç»§ç»­å­¦ä¹ ',
          subtitle: `è·ä»Šæ—¥ç›®æ ‡è¿˜å·® ${remainingGoal} é¢˜`,
          icon: 'ğŸ“š',
          count: Math.min(remainingGoal, 30),
          color: '#4ECDC4'
        };
        cards.push(newCard);
      }

      // å¦‚æœæ²¡æœ‰ä»»ä½•æ¨èï¼Œæ·»åŠ é»˜è®¤æ¨è
      if (cards.length === 0) {
        const defaultCard: RecommendCard = {
          type: RecommendType.DAILY_TASK,
          title: 'å¼€å§‹å­¦ä¹ ',
          subtitle: 'æ¯å¤©è¿›æ­¥ä¸€ç‚¹ç‚¹',
          icon: 'ğŸš€',
          count: 20,
          color: '#667eea'
        };
        cards.push(defaultCard);
      }

    } catch (error) {
      Logger.error('[SmartRecommendService] Failed to get recommend cards', error as Error);
    }

    return cards;
  }

  /**
   * è·å–æœ€è–„å¼±çš„ç§‘ç›®
   */
  async getWeakestSubject(): Promise<SubjectProgress | null> {
    try {
      const progressList = await this.getAllSubjectProgress();
      
      // ç­›é€‰å‡ºæœ‰åšè¿‡é¢˜ç›®ä½†æ­£ç¡®ç‡è¾ƒä½çš„ç§‘ç›®
      const weakSubjects = progressList.filter((p: SubjectProgress) => 
        p.completedCount > 0 && p.accuracy < 70
      );

      if (weakSubjects.length === 0) {
        // å¦‚æœæ²¡æœ‰è–„å¼±ç§‘ç›®ï¼Œè¿”å›è¿›åº¦æœ€ä½çš„ç§‘ç›®
        const lowProgress = progressList.filter((p: SubjectProgress) => p.progress < 50);
        if (lowProgress.length > 0) {
          lowProgress.sort((a: SubjectProgress, b: SubjectProgress) => a.progress - b.progress);
          return lowProgress[0];
        }
        return null;
      }

      // æŒ‰æ­£ç¡®ç‡æ’åºï¼Œè¿”å›æœ€ä½çš„
      weakSubjects.sort((a: SubjectProgress, b: SubjectProgress) => a.accuracy - b.accuracy);
      return weakSubjects[0];
    } catch (error) {
      Logger.error('[SmartRecommendService] Failed to get weakest subject', error as Error);
      return null;
    }
  }

  /**
   * è·å–æ‰€æœ‰ç§‘ç›®çš„å­¦ä¹ è¿›åº¦
   */
  async getAllSubjectProgress(): Promise<SubjectProgress[]> {
    const progressList: SubjectProgress[] = [];

    try {
      const stats = await questionBankService.getQuestionBankStats();
      
      for (const subject of stats.subjects) {
        const progress = await this.getSubjectProgress(subject);
        progressList.push(progress);
      }
    } catch (error) {
      Logger.error('[SmartRecommendService] Failed to get all subject progress', error as Error);
    }

    return progressList;
  }

  /**
   * è·å–å•ä¸ªç§‘ç›®çš„å­¦ä¹ è¿›åº¦
   */
  async getSubjectProgress(subject: SubjectStats): Promise<SubjectProgress> {
    try {
      // è·å–è¯¥ç§‘ç›®çš„é”™é¢˜æ•°ï¼ˆç®€åŒ–å¤„ç†ï¼‰
      const wrongQuestions = await answerRecordService.getWrongQuestions();
      let wrongCount = 0;
      
      // ç®€åŒ–ï¼šæŒ‰æ¯”ä¾‹ä¼°ç®—è¯¥ç§‘ç›®çš„é”™é¢˜æ•°
      const stats = await questionBankService.getQuestionBankStats();
      const totalQuestions = stats.totalCount;
      if (totalQuestions > 0 && subject.questionCount > 0) {
        const ratio = subject.questionCount / totalQuestions;
        wrongCount = Math.round(wrongQuestions.length * ratio);
      }

      // ä¼°ç®—å®Œæˆæ•°é‡
      const completedCount = await this.getSubjectCompletedCount(subject.id);
      const correctCount = Math.max(0, completedCount - wrongCount);

      // è®¡ç®—è¿›åº¦å’Œæ­£ç¡®ç‡
      const progress = subject.questionCount > 0 
        ? Math.round((completedCount / subject.questionCount) * 100) 
        : 0;
      const accuracy = completedCount > 0 
        ? Math.round((correctCount / completedCount) * 100) 
        : 0;

      // è®¡ç®—æŒæ¡ç¨‹åº¦
      const mastery = this.calculateMasteryLevel(progress, accuracy);

      const result: SubjectProgress = {
        subjectId: subject.id,
        subjectName: subject.name,
        shortName: subject.shortName,
        color: subject.color,
        totalCount: subject.questionCount,
        completedCount: completedCount,
        correctCount: correctCount,
        wrongCount: wrongCount,
        progress: Math.min(progress, 100),
        accuracy: accuracy,
        masteryLevel: mastery.level,
        masteryColor: mastery.color
      };

      return result;
    } catch (error) {
      Logger.error('[SmartRecommendService] Failed to get subject progress', error as Error);
      const defaultResult: SubjectProgress = {
        subjectId: subject.id,
        subjectName: subject.name,
        shortName: subject.shortName,
        color: subject.color,
        totalCount: subject.questionCount,
        completedCount: 0,
        correctCount: 0,
        wrongCount: 0,
        progress: 0,
        accuracy: 0,
        masteryLevel: 'æœªå¼€å§‹',
        masteryColor: '#999999'
      };
      return defaultResult;
    }
  }

  /**
   * è·å–ç§‘ç›®å·²å®Œæˆé¢˜ç›®æ•°ï¼ˆå»é‡ï¼‰
   */
  private async getSubjectCompletedCount(subjectId: string): Promise<number> {
    try {
      const totalCompleted = await answerRecordService.getCompletedQuestionCount();
      const stats = await questionBankService.getQuestionBankStats();
      const totalQuestions = stats.totalCount;
      
      if (totalQuestions === 0) return 0;
      
      const subjectStats = stats.subjects.find((s: SubjectStats) => s.id === subjectId);
      if (!subjectStats) return 0;

      // æŒ‰æ¯”ä¾‹ä¼°ç®—
      const ratio = subjectStats.questionCount / totalQuestions;
      return Math.round(totalCompleted * ratio);
    } catch (error) {
      return 0;
    }
  }

  /**
   * è®¡ç®—æŒæ¡ç¨‹åº¦
   */
  private calculateMasteryLevel(progress: number, accuracy: number): MasteryResult {
    if (progress === 0) {
      const result: MasteryResult = { level: 'æœªå¼€å§‹', color: '#999999' };
      return result;
    }
    
    // ç»¼åˆè¯„åˆ† = è¿›åº¦ * 0.4 + æ­£ç¡®ç‡ * 0.6
    const score = progress * 0.4 + accuracy * 0.6;

    if (score >= 90) {
      const result: MasteryResult = { level: 'ç²¾é€š', color: '#52C41A' };
      return result;
    } else if (score >= 75) {
      const result: MasteryResult = { level: 'æŒæ¡', color: '#1890FF' };
      return result;
    } else if (score >= 60) {
      const result: MasteryResult = { level: 'ç†Ÿæ‚‰', color: '#FAAD14' };
      return result;
    } else if (score >= 30) {
      const result: MasteryResult = { level: 'å…¥é—¨', color: '#FF7A45' };
      return result;
    } else {
      const result: MasteryResult = { level: 'å­¦ä¹ ä¸­', color: '#FF4D4F' };
      return result;
    }
  }

  /**
   * è·å–å­¦ä¹ å»ºè®®
   */
  async getStudySuggestions(): Promise<StudySuggestion[]> {
    const suggestions: StudySuggestion[] = [];

    try {
      const todayStats = await answerRecordService.getTodayStatistics();
      const wrongCount = await answerRecordService.getWrongQuestionCount();
      const weakSubject = await this.getWeakestSubject();

      // æ ¹æ®ä»Šæ—¥å­¦ä¹ æƒ…å†µç»™å‡ºå»ºè®®
      if (todayStats.total === 0) {
        const suggestion: StudySuggestion = {
          icon: 'ğŸŒ…',
          title: 'å¼€å§‹ä»Šæ—¥å­¦ä¹ ',
          description: 'æ–°çš„ä¸€å¤©ï¼Œä»åˆ·é¢˜å¼€å§‹ï¼å»ºè®®å…ˆå®Œæˆ20é“åŸºç¡€é¢˜çƒ­èº«ã€‚',
          action: 'start_practice',
          priority: 1
        };
        suggestions.push(suggestion);
      } else if (todayStats.total < 30) {
        const suggestion: StudySuggestion = {
          icon: 'ğŸ’ª',
          title: 'ç»§ç»­åŠ æ²¹',
          description: `ä»Šæ—¥å·²å®Œæˆ ${todayStats.total} é¢˜ï¼Œå†åš ${30 - todayStats.total} é¢˜è¾¾åˆ°åŸºç¡€ç›®æ ‡ï¼`,
          action: 'continue_practice',
          priority: 1
        };
        suggestions.push(suggestion);
      }

      // é”™é¢˜å»ºè®®
      if (wrongCount > 10) {
        const suggestion: StudySuggestion = {
          icon: 'ğŸ“•',
          title: 'é”™é¢˜éœ€è¦å¤ä¹ ',
          description: `ä½ æœ‰ ${wrongCount} é“é”™é¢˜å¾…å¤ä¹ ï¼Œå»ºè®®æ¯å¤©å¤ä¹ 10é“å·©å›ºè®°å¿†ã€‚`,
          action: 'review_wrong',
          priority: 2
        };
        suggestions.push(suggestion);
      }

      // è–„å¼±ç§‘ç›®å»ºè®®
      if (weakSubject && weakSubject.accuracy < 60) {
        const suggestion: StudySuggestion = {
          icon: 'ğŸ¯',
          title: `${weakSubject.shortName}éœ€è¦åŠ å¼º`,
          description: `è¯¥ç§‘ç›®æ­£ç¡®ç‡ä»… ${weakSubject.accuracy}%ï¼Œå»ºè®®é‡ç‚¹çªç ´ã€‚`,
          action: 'focus_weak',
          priority: 3
        };
        suggestions.push(suggestion);
      }

      // æ­£ç¡®ç‡å»ºè®®
      if (todayStats.total > 10 && todayStats.accuracy < 70) {
        const suggestion: StudySuggestion = {
          icon: 'ğŸ“–',
          title: 'å»ºè®®å…ˆçœ‹çŸ¥è¯†ç‚¹',
          description: 'ä»Šæ—¥æ­£ç¡®ç‡è¾ƒä½ï¼Œå»ºè®®å…ˆå­¦ä¹ ç›¸å…³çŸ¥è¯†ç‚¹å†åšé¢˜ã€‚',
          action: 'learn_knowledge',
          priority: 2
        };
        suggestions.push(suggestion);
      }

    } catch (error) {
      Logger.error('[SmartRecommendService] Failed to get suggestions', error as Error);
    }

    // æŒ‰ä¼˜å…ˆçº§æ’åº
    suggestions.sort((a: StudySuggestion, b: StudySuggestion) => a.priority - b.priority);
    return suggestions;
  }
}

export const smartRecommendService = SmartRecommendService.getInstance();
