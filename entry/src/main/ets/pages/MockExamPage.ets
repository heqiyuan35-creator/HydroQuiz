/**
 * æ¨¡æ‹Ÿè€ƒè¯•ç­”é¢˜é¡µé¢
 * HydroQuiz - æ°´åˆ©å·¥ç¨‹æ£€æµ‹å‘˜åˆ·é¢˜å®
 */
import { Router, RouteParams } from '../router/Router';
import { ThemeColors } from '../theme/ThemeColors';
import { ThemeConstants } from '../theme/ThemeConstants';
import { AppConstants } from '../common/constants/AppConstants';
import { Question, QuestionType, QuestionOption } from '../common/types/QuestionTypes';
import { questionService } from '../services/QuestionService';
import {
  mockExamService,
  ExamType,
  ExamConfig,
  ExamProgress,
  ExamResult,
  getExamPreset
} from '../services/MockExamService';
import { getSubjectShortName, getSubjectColor } from '../data/SubjectData';
import { Logger } from '../common/utils/Logger';
import { promptAction } from '@kit.ArkUI';

@Entry
@Component
struct MockExamPage {
  @State isLoading: boolean = true;
  @State examConfig: ExamConfig | null = null;
  @State questions: Question[] = [];
  @State currentIndex: number = 0;
  @State currentQuestion: Question | null = null;  // å½“å‰é¢˜ç›®ï¼Œç”¨äºè§¦å‘UIæ›´æ–°
  @State userAnswers: Map<string, string> = new Map();
  @State markedIds: Set<string> = new Set();
  @State remainingTime: number = 0;
  @State showAnswerCard: boolean = false;
  @State isSubmitting: boolean = false;
  // å¤šé€‰é¢˜ä¸´æ—¶é€‰æ‹©
  @State tempMultipleAnswers: Set<string> = new Set();
  // æ ‡è®°æŒ‰é’®åŠ¨ç”»
  @State markButtonScale: number = 1;

  private timerId: number = -1;
  private progressId: string = '';
  private startTime: number = 0;

  aboutToAppear(): void {
    this.initExam();
  }

  aboutToDisappear(): void {
    this.stopTimer();
    // åªæœ‰åœ¨æœªæäº¤çŠ¶æ€ä¸‹æ‰ä¿å­˜è¿›åº¦ï¼Œé¿å…äº¤å·ååˆä¿å­˜
    if (!this.isSubmitting) {
      this.saveProgressQuietly();
    }
  }

  private async initExam(): Promise<void> {
    const params: RouteParams = Router.getParams();
    const continueExam = params['continueExam'] as boolean;

    if (continueExam) {
      await this.loadSavedProgress();
    } else {
      const examType = (params['examType'] as string || 'full') as ExamType;
      const subjectId = params['subjectId'] as string;
      await this.startNewExam(examType, subjectId);
    }
  }

  private async loadSavedProgress(): Promise<void> {
    try {
      const progress = await mockExamService.loadProgress();
      if (!progress) {
        promptAction.showToast({ message: 'æœªæ‰¾åˆ°è€ƒè¯•è¿›åº¦', duration: 2000 });
        Router.back();
        return;
      }

      this.progressId = progress.id;
      const preset = getExamPreset(progress.examType);
      const config: ExamConfig = {
        type: preset.type,
        questionCount: preset.questionCount,
        timeLimit: preset.timeLimit,
        scoreRules: preset.scoreRules,
        subjectId: progress.subjectId
      };
      this.examConfig = config;
      this.questions = await questionService.getQuestionsByIds(progress.questionIds);
      this.userAnswers = progress.userAnswers;
      this.markedIds = progress.markedIds;
      this.currentIndex = progress.currentIndex;
      this.setCurrentQuestion(this.currentIndex);
      this.remainingTime = progress.remainingTime;
      this.startTime = Date.now() - (this.examConfig.timeLimit - this.remainingTime) * 1000;

      // æ¢å¤å½“å‰é¢˜ç›®çš„å¤šé€‰çŠ¶æ€
      this.syncTempMultipleAnswers();

      this.startTimer();
      this.isLoading = false;
    } catch (error) {
      Logger.error('[MockExamPage] Failed to load progress', error as Error);
      promptAction.showToast({ message: 'åŠ è½½å¤±è´¥', duration: 2000 });
      Router.back();
    }
  }

  private async startNewExam(examType: ExamType, subjectId?: string): Promise<void> {
    try {
      const preset = getExamPreset(examType);
      const config: ExamConfig = {
        type: preset.type,
        questionCount: preset.questionCount,
        timeLimit: preset.timeLimit,
        scoreRules: preset.scoreRules,
        subjectId: subjectId
      };
      this.examConfig = config;

      this.questions = await mockExamService.generateExam(this.examConfig);

      if (this.questions.length === 0) {
        promptAction.showToast({ message: 'é¢˜åº“é¢˜ç›®ä¸è¶³ï¼Œæ— æ³•å¼€å§‹è€ƒè¯•', duration: 2000 });
        Router.back();
        return;
      }

      this.progressId = `progress_${Date.now()}`;
      this.remainingTime = this.examConfig.timeLimit;
      this.startTime = Date.now();
      this.userAnswers = new Map();
      this.markedIds = new Set();
      this.currentIndex = 0;
      this.setCurrentQuestion(0);

      // æ¸…é™¤æ—§è¿›åº¦å¹¶ä¿å­˜æ–°è¿›åº¦
      await mockExamService.clearProgress();
      await this.saveProgress();

      this.startTimer();
      this.isLoading = false;
    } catch (error) {
      Logger.error('[MockExamPage] Failed to start exam', error as Error);
      promptAction.showToast({ message: 'å¼€å§‹è€ƒè¯•å¤±è´¥', duration: 2000 });
      Router.back();
    }
  }

  private startTimer(): void {
    this.timerId = setInterval(() => {
      if (this.remainingTime > 0) {
        this.remainingTime--;
        // æ¯30ç§’è‡ªåŠ¨ä¿å­˜
        if (this.remainingTime % 30 === 0) {
          this.saveProgressQuietly();
        }
      } else {
        this.stopTimer();
        this.autoSubmit();
      }
    }, 1000);
  }

  private stopTimer(): void {
    if (this.timerId !== -1) {
      clearInterval(this.timerId);
      this.timerId = -1;
    }
  }

  /**
   * è®¾ç½®å½“å‰é¢˜ç›®ï¼ˆåˆ›å»ºæ–°å¯¹è±¡å¼•ç”¨ä»¥è§¦å‘UIæ›´æ–°ï¼‰
   */
  private setCurrentQuestion(index: number): void {
    if (index >= 0 && index < this.questions.length) {
      const q = this.questions[index];
      this.currentQuestion = {
        id: q.id,
        type: q.type,
        subjectId: q.subjectId,
        chapter: q.chapter,
        content: q.content,
        options: [...q.options],  // å¤åˆ¶æ•°ç»„
        answer: q.answer,
        analysis: q.analysis,
        difficulty: q.difficulty,
        tags: [...q.tags],  // å¤åˆ¶æ•°ç»„
        createTime: q.createTime,
        updateTime: q.updateTime
      };
    } else {
      this.currentQuestion = null;
    }
  }

  private async saveProgress(): Promise<void> {
    if (!this.examConfig) return;

    const progress: ExamProgress = {
      id: this.progressId,
      examType: this.examConfig.type,
      subjectId: this.examConfig.subjectId,
      questionIds: this.questions.map(q => q.id),
      userAnswers: this.userAnswers,
      markedIds: this.markedIds,
      currentIndex: this.currentIndex,
      remainingTime: this.remainingTime,
      createTime: this.startTime,
      updateTime: Date.now()
    };

    await mockExamService.saveProgress(progress);
  }

  private saveProgressQuietly(): void {
    this.saveProgress().catch((e: Error) => {
      Logger.error('[MockExamPage] Auto save failed', e);
    });
  }

  private syncTempMultipleAnswers(): void {
    const question = this.currentQuestion;
    if (question && question.type === QuestionType.MULTIPLE) {
      const saved = this.userAnswers.get(question.id);
      if (saved) {
        this.tempMultipleAnswers = new Set(saved.split(','));
      } else {
        this.tempMultipleAnswers = new Set();
      }
    } else {
      this.tempMultipleAnswers = new Set();
    }
  }

  private selectAnswer(optionKey: string): void {
    const question = this.currentQuestion;
    if (!question) return;

    if (question.type === QuestionType.MULTIPLE) {
      // å¤šé€‰é¢˜
      if (this.tempMultipleAnswers.has(optionKey)) {
        this.tempMultipleAnswers.delete(optionKey);
      } else {
        this.tempMultipleAnswers.add(optionKey);
      }
      // æ›´æ–° Map
      const newSet = new Set(this.tempMultipleAnswers);
      this.tempMultipleAnswers = newSet;
      // ä¿å­˜ç­”æ¡ˆ
      if (newSet.size > 0) {
        const sorted = Array.from(newSet).sort();
        this.userAnswers.set(question.id, sorted.join(','));
      } else {
        this.userAnswers.delete(question.id);
      }
    } else {
      // å•é€‰/åˆ¤æ–­
      this.userAnswers.set(question.id, optionKey);
    }
    // è§¦å‘æ›´æ–°
    this.userAnswers = new Map(this.userAnswers);
  }

  private toggleMark(): void {
    const question = this.currentQuestion;
    if (!question) return;

    if (this.markedIds.has(question.id)) {
      this.markedIds.delete(question.id);
    } else {
      this.markedIds.add(question.id);
    }
    this.markedIds = new Set(this.markedIds);
  }

  private goToQuestion(index: number): void {
    if (index >= 0 && index < this.questions.length) {
      this.currentIndex = index;
      this.setCurrentQuestion(index);
      this.syncTempMultipleAnswers();
      this.showAnswerCard = false;
    }
  }

  private prevQuestion(): void {
    if (this.currentIndex > 0) {
      this.goToQuestion(this.currentIndex - 1);
    }
  }

  private nextQuestion(): void {
    if (this.currentIndex < this.questions.length - 1) {
      this.goToQuestion(this.currentIndex + 1);
    }
  }

  private confirmSubmit(): void {
    const unanswered = this.questions.length - this.userAnswers.size;
    const message = unanswered > 0
      ? `è¿˜æœ‰ ${unanswered} é¢˜æœªä½œç­”ï¼Œç¡®å®šäº¤å·å—ï¼Ÿ`
      : 'ç¡®å®šè¦äº¤å·å—ï¼Ÿ';

    const btn1: promptAction.Button = { text: 'ç»§ç»­ç­”é¢˜', color: ThemeColors.TEXT_SECONDARY };
    const btn2: promptAction.Button = { text: 'ç¡®å®šäº¤å·', color: ThemeColors.PRIMARY };
    const options: promptAction.ShowDialogOptions = {
      title: 'äº¤å·ç¡®è®¤',
      message: message,
      buttons: [btn1, btn2]
    };
    promptAction.showDialog(options).then((result: promptAction.ShowDialogSuccessResponse) => {
      if (result.index === 1) {
        this.submitExam();
      }
    });
  }

  private autoSubmit(): void {
    promptAction.showToast({ message: 'è€ƒè¯•æ—¶é—´åˆ°ï¼Œè‡ªåŠ¨äº¤å·', duration: 2000 });
    this.submitExam();
  }

  private async submitExam(): Promise<void> {
    if (this.isSubmitting || !this.examConfig) return;
    this.isSubmitting = true;
    this.stopTimer();

    try {
      // è®¡ç®—æˆç»©
      const result = mockExamService.calculateScore(this.questions, this.userAnswers, this.examConfig);
      const duration = Math.floor((Date.now() - this.startTime) / 1000);
      result.duration = duration;

      // ä¿å­˜è€ƒè¯•è®°å½•ï¼ˆåŒ…å«å®Œæ•´é¢˜ç›®æ•°æ®ï¼‰
      const recordId = await mockExamService.saveExamRecord(
        result,
        this.examConfig,
        this.questions.map(q => q.id),
        this.userAnswers,
        duration,
        this.questions
      );

      // æ¸…é™¤è¿›åº¦
      await mockExamService.clearProgress();

      // è·³è½¬ç»“æœé¡µ
      const resultParams: RouteParams = {};
      resultParams['examRecordId'] = recordId as Object;
      resultParams['examResult'] = result as Object;
      resultParams['examConfig'] = this.examConfig as Object;
      Router.replace('pages/MockExamResultPage', resultParams);
    } catch (error) {
      Logger.error('[MockExamPage] Failed to submit exam', error as Error);
      promptAction.showToast({ message: 'äº¤å·å¤±è´¥ï¼Œè¯·é‡è¯•', duration: 2000 });
      this.isSubmitting = false;
    }
  }

  private formatTime(seconds: number): string {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = seconds % 60;
    if (h > 0) {
      return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
  }

  private getCurrentQuestion(): Question | null {
    return this.currentQuestion;
  }

  private isOptionSelected(optionKey: string): boolean {
    const question = this.currentQuestion;
    if (!question) return false;

    if (question.type === QuestionType.MULTIPLE) {
      return this.tempMultipleAnswers.has(optionKey);
    }
    return this.userAnswers.get(question.id) === optionKey;
  }

  private isOptionSelectedForQuestion(optionKey: string, questionId: string, questionType: QuestionType): boolean {
    if (questionType === QuestionType.MULTIPLE) {
      return this.tempMultipleAnswers.has(optionKey);
    }
    return this.userAnswers.get(questionId) === optionKey;
  }

  build() {
    Stack({ alignContent: Alignment.Top }) {
      // é¡¶éƒ¨èƒŒæ™¯è‰²å»¶ä¼¸åˆ°çŠ¶æ€æ ï¼ˆç»å¯¹å®šä½åœ¨é¡¶éƒ¨ï¼‰
      Column()
        .width('100%')
        .height(AppConstants.STATUS_BAR_HEIGHT + 56)
        .backgroundColor(ThemeColors.SURFACE)
        .position({ x: 0, y: 0 })

      // ä¸»å†…å®¹åŒºåŸŸ
      Column() {
        if (this.isLoading) {
          this.LoadingState()
        } else {
          // é¡¶éƒ¨æ 
          this.TopBar()
          // é¢˜ç›®å†…å®¹
          this.QuestionContent()
          // åº•éƒ¨æ“ä½œæ 
          this.BottomBar()
        }

        // ç­”é¢˜å¡å¼¹çª—
        if (this.showAnswerCard) {
          this.AnswerCardDialog()
        }
      }
      .width('100%')
      .height('100%')
      .padding({ top: AppConstants.STATUS_BAR_HEIGHT })
    }
    .width('100%')
    .height('100%')
    .backgroundColor(ThemeColors.BACKGROUND)
  }

  @Builder
  LoadingState() {
    Column() {
      LoadingProgress().width(48).height(48).color(ThemeColors.PRIMARY)
      Text('æ­£åœ¨åŠ è½½è¯•å·...')
        .fontSize(14)
        .fontColor(ThemeColors.TEXT_SECONDARY)
        .margin({ top: 16 })
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }

  @Builder
  TopBar() {
    Row() {
      // è¿”å›æŒ‰é’®
      Text('â€¹')
        .fontSize(28)
        .fontColor(ThemeColors.TEXT_SECONDARY)
        .width(40)
        .height(40)
        .textAlign(TextAlign.Center)
        .onClick(() => {
          this.saveProgressQuietly();
          Router.back();
        })

      // è¿›åº¦ + å€’è®¡æ—¶
      Row({ space: 6 }) {
        Text(`${this.currentIndex + 1} / ${this.questions.length}`)
          .fontSize(16)
          .fontWeight(FontWeight.Medium)
          .fontColor(ThemeColors.TEXT_PRIMARY)
        Text('ğŸ•')
          .fontSize(14)
        Text(this.formatTime(this.remainingTime))
          .fontSize(14)
          .fontColor(this.remainingTime < 600 ? ThemeColors.ERROR : ThemeColors.TEXT_SECONDARY)
      }
      .layoutWeight(1)
      .justifyContent(FlexAlign.Center)

      // æ ‡è®°æŒ‰é’®
      Text(this.currentQuestion && this.markedIds.has(this.currentQuestion.id) ? 'â˜…' : 'â˜†')
        .fontSize(24)
        .fontColor(this.currentQuestion && this.markedIds.has(this.currentQuestion.id) ? '#FFB800' : ThemeColors.TEXT_HINT)
        .width(40)
        .height(40)
        .textAlign(TextAlign.Center)
        .onClick(() => {
          if (this.currentQuestion) {
            const wasMarked = this.markedIds.has(this.currentQuestion.id);
            this.toggleMark();
            promptAction.showToast({
              message: wasMarked ? 'å·²å–æ¶ˆæ ‡è®°' : 'å·²æ ‡è®°æ­¤é¢˜',
              duration: 1500
            });
          }
        })
    }
    .width('100%')
    .height(56)
    .padding({ left: 8, right: 8 })
    .backgroundColor(ThemeColors.SURFACE)
  }

  @Builder
  QuestionContent() {
    Scroll() {
      Column() {
        if (this.currentQuestion !== null && this.currentIndex >= 0) {
          // é¢˜ç›®æ ‡ç­¾
          Row({ space: 8 }) {
            Text(this.getQuestionTypeName(this.currentQuestion.type) + 'é¢˜')
              .fontSize(12)
              .fontColor(ThemeColors.WHITE)
              .padding({ left: 10, right: 10, top: 4, bottom: 4 })
              .backgroundColor(ThemeColors.PRIMARY)
              .borderRadius(12)

            Text(getSubjectShortName(this.currentQuestion.subjectId))
              .fontSize(12)
              .fontColor(ThemeColors.WHITE)
              .padding({ left: 10, right: 10, top: 4, bottom: 4 })
              .backgroundColor(getSubjectColor(this.currentQuestion.subjectId))
              .borderRadius(12)
          }
          .width('100%')

          // é¢˜ç›®å†…å®¹
          Text(this.currentQuestion.content)
            .fontSize(17)
            .fontColor(ThemeColors.TEXT_PRIMARY)
            .lineHeight(28)
            .margin({ top: 16, bottom: 24 })
            .width('100%')

          // é€‰é¡¹åˆ—è¡¨
          Column({ space: 12 }) {
            ForEach(this.currentQuestion.options, (option: QuestionOption) => {
              this.OptionItem(option, this.currentQuestion!.type, this.currentQuestion!.id)
            }, (option: QuestionOption) => `${this.currentQuestion!.id}_${option.key}`)
          }
          .width('100%')
        }
      }
      .width('100%')
      .padding({ left: 20, right: 20, top: 16, bottom: 16 })
      .alignItems(HorizontalAlign.Start)
    }
    .scrollBar(BarState.Off)
    .layoutWeight(1)
    .backgroundColor(ThemeColors.SURFACE)
  }

  @Builder
  OptionItem(option: QuestionOption, questionType: QuestionType, questionId: string) {
    Row() {
      // é€‰é¡¹å­—æ¯åœ†åœˆ - å¸¦è¾¹æ¡†æ ·å¼
      Row() {
        Text(option.key)
          .fontSize(15)
          .fontWeight(FontWeight.Medium)
          .fontColor(this.isOptionSelectedForQuestion(option.key, questionId, questionType) ? ThemeColors.WHITE : ThemeColors.PRIMARY)
      }
      .width(32)
      .height(32)
      .justifyContent(FlexAlign.Center)
      .backgroundColor(this.isOptionSelectedForQuestion(option.key, questionId, questionType) ? ThemeColors.PRIMARY : ThemeColors.SURFACE)
      .border({
        width: 1.5,
        color: ThemeColors.PRIMARY
      })
      .borderRadius(16)

      // é€‰é¡¹å†…å®¹
      Text(option.content)
        .fontSize(15)
        .fontColor(ThemeColors.TEXT_PRIMARY)
        .layoutWeight(1)
        .margin({ left: 14 })
        .maxLines(10)
    }
    .width('100%')
    .padding({ left: 14, right: 16, top: 16, bottom: 16 })
    .backgroundColor(ThemeColors.SURFACE)
    .borderRadius(12)
    .border({
      width: 1,
      color: this.isOptionSelectedForQuestion(option.key, questionId, questionType) ? ThemeColors.PRIMARY : ThemeColors.BORDER
    })
    .onClick(() => { this.selectAnswer(option.key); })
  }

  @Builder
  BottomBar() {
    Column() {
      // ç­”é¢˜å¡å…¥å£
      Row() {
        Text('ç­”é¢˜å¡')
          .fontSize(14)
          .fontColor(ThemeColors.PRIMARY)
        Text(` (å·²ç­” ${this.userAnswers.size}/${this.questions.length})`)
          .fontSize(13)
          .fontColor(ThemeColors.TEXT_HINT)
        Text(this.showAnswerCard ? ' â–²' : ' â–¼')
          .fontSize(12)
          .fontColor(ThemeColors.PRIMARY)
      }
      .width('100%')
      .justifyContent(FlexAlign.Center)
      .padding({ top: 10, bottom: 8 })
      .onClick(() => { this.showAnswerCard = !this.showAnswerCard; })

      // åº•éƒ¨æŒ‰é’®
      Row({ space: 12 }) {
        // ä¸Šä¸€é¢˜
        Button('ä¸Šä¸€é¢˜')
          .fontSize(15)
          .fontColor(this.currentIndex > 0 ? ThemeColors.PRIMARY : ThemeColors.TEXT_HINT)
          .backgroundColor(ThemeColors.BACKGROUND)
          .borderRadius(24)
          .height(44)
          .layoutWeight(1)
          .enabled(this.currentIndex > 0)
          .onClick(() => { this.prevQuestion(); })

        // äº¤å·æŒ‰é’®
        Button('äº¤å·')
          .fontSize(15)
          .fontColor(ThemeColors.WHITE)
          .backgroundColor('#FF6B6B')
          .borderRadius(24)
          .height(44)
          .width(80)
          .onClick(() => { this.confirmSubmit(); })

        // ä¸‹ä¸€é¢˜
        Button('ä¸‹ä¸€é¢˜')
          .fontSize(15)
          .fontColor(ThemeColors.WHITE)
          .backgroundColor(ThemeColors.PRIMARY)
          .borderRadius(24)
          .height(44)
          .layoutWeight(1)
          .onClick(() => {
            if (this.currentIndex < this.questions.length - 1) {
              this.nextQuestion();
            } else {
              this.confirmSubmit();
            }
          })
      }
      .width('100%')
      .padding({ left: 16, right: 16, bottom: 32 })
    }
    .width('100%')
    .backgroundColor(ThemeColors.SURFACE)
    .border({ width: { top: 1 }, color: ThemeColors.BORDER })
  }

  @Builder
  AnswerCardDialog() {
    Column() {
      // é®ç½©
      Column()
        .width('100%')
        .height('100%')
        .backgroundColor('rgba(0,0,0,0.5)')
        .onClick(() => { this.showAnswerCard = false; })
    }
    .width('100%')
    .height('100%')
    .position({ x: 0, y: 0 })

    Column() {
      // æ ‡é¢˜
      Row() {
        Text('ç­”é¢˜å¡')
          .fontSize(18)
          .fontWeight(FontWeight.Bold)
          .fontColor(ThemeColors.TEXT_PRIMARY)

        Blank()

        Text('âœ•')
          .fontSize(20)
          .fontColor(ThemeColors.TEXT_HINT)
          .onClick(() => { this.showAnswerCard = false; })
      }
      .width('100%')
      .padding({ left: 20, right: 20, top: 16, bottom: 12 })

      // å›¾ä¾‹
      Row({ space: 16 }) {
        this.LegendItem('â—', 'å·²ç­”', ThemeColors.PRIMARY)
        this.LegendItem('â—‹', 'æœªç­”', ThemeColors.GRAY_300)
        this.LegendItem('âš‘', 'æ ‡è®°', ThemeColors.WARNING)
      }
      .width('100%')
      .padding({ left: 20, right: 20, bottom: 12 })

      // é¢˜å·ç½‘æ ¼
      Scroll() {
        Flex({ wrap: FlexWrap.Wrap }) {
          ForEach(this.questions, (question: Question, index: number) => {
            this.AnswerCardItem(question, index)
          }, (question: Question, index: number) => `${question.id}_${index}`)
        }
        .width('100%')
        .padding({ left: 16, right: 16 })
      }
      .scrollBar(BarState.Off)
      .layoutWeight(1)
    }
    .width('100%')
    .height('50%')
    .backgroundColor(ThemeColors.SURFACE)
    .borderRadius({ topLeft: 20, topRight: 20 })
    .position({ x: 0, y: '50%' })
  }

  @Builder
  LegendItem(icon: string, label: string, color: ResourceColor) {
    Row({ space: 4 }) {
      Text(icon)
        .fontSize(14)
        .fontColor(color)
      Text(label)
        .fontSize(12)
        .fontColor(ThemeColors.TEXT_SECONDARY)
    }
  }

  @Builder
  AnswerCardItem(question: Question, index: number) {
    Column() {
      Text(`${index + 1}`)
        .fontSize(13)
        .fontColor(this.getCardItemColor(question))
    }
    .width(40)
    .height(40)
    .margin(4)
    .justifyContent(FlexAlign.Center)
    .backgroundColor(this.getCardItemBgColor(question))
    .borderRadius(8)
    .border({
      width: this.currentIndex === index ? 2 : 1,
      color: this.currentIndex === index ? ThemeColors.PRIMARY : ThemeColors.BORDER
    })
    .onClick(() => { this.goToQuestion(index); })
  }

  private getCardItemColor(question: Question): ResourceColor {
    if (this.userAnswers.has(question.id)) {
      return ThemeColors.WHITE;
    }
    if (this.markedIds.has(question.id)) {
      return ThemeColors.WARNING;
    }
    return ThemeColors.TEXT_SECONDARY;
  }

  private getCardItemBgColor(question: Question): ResourceColor {
    if (this.userAnswers.has(question.id)) {
      return ThemeColors.PRIMARY;
    }
    if (this.markedIds.has(question.id)) {
      return '#FFF7E6';
    }
    return ThemeColors.SURFACE;
  }

  private getQuestionTypeName(type: QuestionType): string {
    switch (type) {
      case QuestionType.SINGLE: return 'å•é€‰';
      case QuestionType.MULTIPLE: return 'å¤šé€‰';
      case QuestionType.JUDGE: return 'åˆ¤æ–­';
      default: return 'å…¶ä»–';
    }
  }
}
